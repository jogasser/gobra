// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

package termination

type FactEven interface {
  requires n >= 0
  decreases n
  factEven(n int) int
}

type FactOdd interface {
  requires n >= 0
  decreases n
  factOdd(n int) int
}

type FactEvenImpl struct {}
  requires v >= 0
  decreases v
  func(x FactEvenImpl)factEven(v int) int {
    if v == 0 {
      return 0
    } else {
      var y FactOdd = FactOddImpl{}
      return v * y.factOdd(v - 1)
    }
  }

type FactOddImpl struct {}
  requires v >= 0
  decreases v
  func(y FactOddImpl)factOdd(v int) int {
    if v == 0 {
      return 0
    } else if v == 1 {
        return 1
    } else {
        var y FactEven = FactEvenImpl{}
        return v * y.factEven(v - 1)
    }
  }

type FactEvenImplNotTer struct {}
  requires v >= 0
  decreases v
  func(x FactEvenImplNotTer)factEven(v int) int {
    if v == 0 {
      return 0
    } else {
      var y FactOdd = FactOddImplNotTer{}

      //:: ExpectedOutput(method_termination_error)
      return v * y.factOdd(v)
      }
    }

type FactOddImplNotTer struct {}
  requires v >= 0
  decreases v
  func(y FactOddImplNotTer)factOdd(v int) int {
    if v == 0 {
      return 0
    } else if v == 1 {
        return 1
    } else {
        var y FactEven = FactEvenImplNotTer{}
        return v * y.factEven(v - 1)
    }
  }

type IsEven interface {
  requires n >= 0
  decreases n
  isEven(n int) bool
}

type IsOdd interface {
  requires n >= 0
  decreases n
  isOdd(n int) bool
}

type IsEvenImpl struct {}
  requires n >= 0
  decreases n
  func(y IsEvenImpl)isEven(n int) bool {
    if n == 0 {
      return true
    } else {
      var y IsOdd = IsOddImpl{}
      return y.isOdd(n - 1)
    }
  }

type IsOddImpl struct {}
  requires n >= 0
  decreases n
  func(y IsOddImpl)isOdd(n int) bool {
    if n == 0 {
      return true
    } else {
      var y IsEven = IsEvenImpl{}
      return y.isEven(n - 1)
    }
  }

type IsEvenImpl2 struct {}
  requires n >= 0
  decreases n
  func(y IsEvenImpl2)isEven(n int) bool {
    if n == 0 {
      return true
    } else {
      var y IsOdd = IsOddImpl2{}
      return y.isOdd(n - 1)
    }
  }

type IsOddImpl2 struct {}
  requires n >= 0
  decreases n
  func(y IsOddImpl2)isOdd(n int) bool {
    if n == 0 {
      return true
    } else {
      var y IsEven = IsEvenImpl{}
        
      //:: ExpectedOutput(method_termination_error)
      return y.isEven(n)
    }
  }
  
type Fun1 interface {
  decreases m, n
  fun1(m int, n bool) int
}

type Fun2 interface {
  decreases n
  fun2(n int) int
}

type Fun1Impl struct {}
  decreases m, n
  func(y Fun1Impl)fun1(m int, n bool) int {
    var temp1 int
    var temp2 int
    if n {
      temp1 = y.fun1(m, false)
    } else {
      temp1 = 1
    }
    if m > 0 {
      var y Fun2 = Fun2Impl{}
      temp2 = y.fun2(m - 1)
    } else {
      temp2 = 2
    }
    return temp1 + temp2
  }

type Fun2Impl struct {}
  decreases n
  func(y Fun2Impl)fun2(n int) int {
    if n > 0 {
      var y Fun1 = Fun1Impl{}
      return y.fun1(n-1, true)
    } else {
      return 3
    }
  }

type Fun1ImplNotTer struct {}
  decreases m, n
  func(y Fun1ImplNotTer)fun1(m int, n bool) int {
    var temp1 int
    var temp2 int
    if n {
      temp1 = y.fun1(m,false)
    } else {
      temp1 = 1
    }
    if m > 0 {
      var y Fun2 = Fun2ImplNotTer{}
      
      //:: ExpectedOutput(method_termination_error)
      temp2 = y.fun2(m)
    } else {
      temp2 = 2
    }
    return temp1 + temp2
  }

type Fun2ImplNotTer struct {}
  decreases n
  func(y Fun2ImplNotTer)fun2(n int) int {
    if n > 0 {
      var y Fun1 = Fun1ImplNotTer{}
      return y.fun1(n-1, true)
    } else {
      return 3
    }
  }

type Infinite1 interface {
  decreases _
  infinite1(n int) int
}

type Infinite2 interface {
  decreases _
  infinite2(n int) int
}

type Infinite1Impl struct {}
  decreases _
  func(y Infinite1Impl)infinite1(n int) int {
    var x Infinite2 = Infinite2Impl{}
    return x.infinite2(n)
  }

type Infinite2Impl struct {}
  decreases _
  func(y Infinite2Impl)infinite2(n int) int {
    var x Infinite1 = Infinite1Impl{}
    return x.infinite1(n)
  }

type TestConditional1 interface {
  decreases x if 1 <= x
  decreases _ if x <= -1
  decreases *
  testConditional1(x int) int
}

type TestConditional2 interface {
  decreases x if 1 <= x
  decreases _ if x <= -1
  decreases *
  testConditional2(x int) int
}

type TestConditional1Impl struct {}
  decreases x if 1 <= x
  decreases _ if x <= -1
  decreases *
  func(y TestConditional1Impl)testConditional1(x int) int {
    var z TestConditional2 = TestConditional2Impl{}
    if x == 0 {
      return z.testConditional2(x)
    } else {
      if 1 < x {
 
      //:: ExpectedOutput(method_termination_error)
      return z.testConditional2(x)
      } else {
        if x < -1 {
          return z.testConditional2(x + 1)
        } else {
          return x
        }
      }
    }
  }

type TestConditional2Impl struct {}
  decreases x if 1 <= x
  decreases _ if x <= -1
  decreases *
  func(y TestConditional2Impl)testConditional2(x int) int {
    var z TestConditional1 = TestConditional1Impl{}
    if x == 0 {
      return z.testConditional1(x)
    } else {
      if 1 < x {
        return z.testConditional1(x - 1)
      } else {
        if x < -1 {
          return z.testConditional1(x + 1)
        } else {
          return x
        }
      }
    }
  }

